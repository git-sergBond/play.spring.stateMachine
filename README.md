# Play with StateMachine

ТЗ:
Приложение будет абстракцией на процесс покупки
Продукт при покупке будет проходить стадии new, reserved, reserved decline и purchase complete.

/**
добавить сюда диаграмму состояний uml **/

Docs:
https://www.google.com/search?q=%40Bean&oq=%40Bean&aqs=chrome..69i57j69i65l2&sourceid=chrome&ie=UTF-8

Original:
https://habr.com/ru/post/462371/
https://github.com/mypanacea/statemachine

TODO:
* try use spring-statemachine-test library for testing
* try alternative for EnumStateMachineConfigurerAdapter
* Spring statemachine, пройтись по всей доке и описать все кейсы
* enum поля (NEW, RESERVED, CANCEL_RESERVED, PURCHASE_COMPLETE), можно захардкодить в них что-нибудь, свойственное например, конкретному state, что довольно логично(мы так и поступили решая свой кейс, довольно удобно).
* Следующий важный момент одна ли машина будет жить в контексте приложения: в единственном экземпляре @EnableStateMachine, или каждый раз будет создаваться новая @EnableStateMachineFactory.
* многопользовательское веб-приложение, с кучей пользователей @EnableStateMachineFactory
* StateMachine так же может быть создана через builder как обычный bean (см.документацию), что бывает удобно в отдельных случаях(например вам нужно чтобы машина обязательно была явно объявлена как bean), и если это отдельный бин, то мы можем указать ему свой scope, например session или request.
* В нашем проекте, над бином statemachine был реализован wrapper(особенности нашей бизнес-логики), wrapper был singleton, а сама машина prototype
* чего он тут нагородил? Цитата: Как реализовать prototype в singlton-е?По сути все что требуется сделать это получать каждый раз при обращении к объекту новый bean из applicationContext. Inject-ать applicationContext в бизнес-логику грех, поэтому bean statemachine должен либо реализовывать интерфейс с хотя бы одним методом, либо абстрактный метод(method injection), при создании в java — конфиге потребуется реализовать обозначенный абстрактный метод, а в реализации мы будем дергать из applicationContext новый bean. Иметь в config классе ссылку на applicationContext нормальная практика, и через абстрактный метод мы будет вызвать из контекста .getBean()
* в этом же конфиге можно задать отдельный TaskExecutor, что удобно тогда, когда на каком-то их переходов выполняется долгий Action, а приложение должно идти дальше.
StateMachine.png
***

Помимо «навешивания» Action в transitions можно также «навешивать» их в методе configure для state, примерно в таком виде:
    @Override
    public void configure(final StateMachineStateConfigurer<PurchaseState, PurchaseEvent> states) throws Exception {
        states
                .withStates()
                .initial(NEW)
                .end(PURCHASE_COMPLETE)
                .stateEntry()
                .stateExit()
                .state()
                .states(EnumSet.allOf(PurchaseState.class));
    }

Все в зависимости от того как именно вы хотите запускать action
Грабли
Учтите, что если вы укажете action при конфигурировании state(), например так
        states
                .withStates()
                .initial(NEW)
                .end(PURCHASE_COMPLETE)
                .state(randomAction())

он будет выполняться асинхронно, предполагается что если вы например говорите .stateEntry(), то Action должен быть выполнен непосредственно при входе, но если вы говорите .state() значит Action должен быть выполнен в целевом state, но не так важно когда именно.
В нашем проекте мы сконфигурировали все Action на transition конфиге, благо навешивать их можно по нескольку на один переход.

***

***
А вы знаете, почему работая со Spring важно создавать bean через интерфейс? Столкнулись с этой проблемой(ну да-да и Женя Борисов рассказывал в потрошителе), когда однажды в контроллере попытались за-implement-ить самодельный не пустой интерфейс. Spring создает прокси на компоненты, и если компонент не реализует ни один интерфейс, то он сделает это через CGLIB, но как только вы реализуете какой-то интерфейс — Spring попытается создать прокси через dynamic-прокси, в результате вы получите непонятный тип объекта и NoSuchBeanDefinitionException.
***

***
В нашем проекте механизм сохранения и восстановления состояний из коробки нам не подошел, так как статусы машины мы хранили в БД и их мог менять job, который ничего не знал о машине.
Пришлось завязываться на статус полученный из БД, делать некий InitAction который при старте машины получал статус из БД, и выставлял его принудительно, и только потом бросал event, пример кода который выполняет вышесказанное:
stateMachine
                .getStateMachineAccessor()
                .doWithAllRegions(access -> {
                    access.resetStateMachine(new DefaultStateMachineContext<>({ResetState}, null, null, null, null));
                });
stateMachine.start();
stateMachine.sendEvent({NewEventFromResetState});
***

***
1. Резервирование и последующий отказ от покупки. Отправим приложению запрос на URI "/reserve", с параметрами userId=007, productId=10001, а следом за ним запрос "/cancel" c параметром userId=007 вывод консоли будет следующим:
Machine started
Товар с номером 10001 зарезервирован.
Переход из статуса NEW в статус RESERVED
Machine started
Резервирование товара 10001 отменено
Переход из статуса RESERVED в статус CANCEL_RESERVED
2. Резервирование и успешная покупка:
Machine started
Товар с номером 10001 зарезервирован.
Переход из статуса NEW в статус RESERVED
Machine started
Товар с номером 10001 успешно куплен

   Не работает ->    Переход из статуса RESERVED в статус PURCHASE_COMPLETE
***

***
Не рассматривал в статье, но хочется упомянуть про такие возможности как choice, это своеобразный триггер, который работает по принципу switch, где на кейсы навешиваются Guards, и машина поочередно пытается пойти в тот стейт, который описан в choice конфиге и куда его пустит Guard, без какие то Events, это удобно, когда при инициализации машины, нам необходимо автоматически перейти в какой то псевдостейт.
***

//TODO @SuppressWarnings("unused")

Links:
* https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82
* https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
* https://medium.com/datadriveninvestor/state-machine-design-pattern-part-2-state-pattern-vs-state-machine-3010dd0fcf28

aleksandy
5 августа 2019 в 11:32
Как реализовать prototype в singlton-е?
ObjectFactory. Да, сервис придётся завязывать на спринговый интерфейс, но это лучше, чем завязка на контекст.
Плюсом идёт отсутствие необходимости в поднятии спрингового контекста для тестирования.
Ещё можно через BeanFactoryAware запилить, но это, по-сути, та же завязка на контекст приложения.
Основное преимущество описанного мной подхода в том что это будет возможность протестировать машину через unit-тест, а не через интеграционный или функциональный, если у вас в интеграционном тесте перед каждым тестом в тестовом профиле накатываются схемы в БД, таблицы и прочее прочее прочее, то ваши интеграционные тесты со временем нормально так затягиваютс
я, и вы точно предпочтете тестировать через Unit, если будет такая возможность

Спасибо за статью. Скажите а данная машина состояний персистентна? Что будет если приложение остановили, когда процесс был в каком — то промежуточном статусе(не в начальном и не в end), а затем включим: процесс будет потерян, продолжится или как?
PS: если это было в статье и я не заметил ответ на мой вопрос — прошу прощения
Ответить

mypanacea87
4 августа 2019 в 13:13

+1
Добрый день. Тут будет зависеть от scope машины, если она singleton, и она находится в каком то промежуточном статусу, то она будет находиться в нем до тех пор пока не остановится спринговый контекст, либо пока вы явно не скажете ей .stop()(после этого она перейдет в конечное состояние, которое вы закодировали). В случае если вы получаете машину из фабрики, то при каждом обращении к сервису будет создаваться новая машина, соответственно при каждом запросе вы сохраняете ее состояние в базу или в Map, как у меня в примере, а при повторном запросе восстанавливаете ее, то есть если машина в промежуточном состоянии и у вас настроен персистинг, то вы вернетесь в то же самое промежуточное состояние.
Ответить
Jhumper
5 августа 2019 в 14:23

0
Добрый день! Спасибо за статью. У меня продолжение для предыдущего вопроса. Если машина была остановлена когда уже получила новый евент, но ещё не успела обработать его можно ли как-то зареплаить этот евент при восстановлении чтобы не перепосылать (тут вопрос наверно про транзакционность и DR)? И есть ли возможность каких-то STP. Например для мы кинули евент RESERVED, а машина дальше допинала через BUY по определённому условию?
Ответить

mypanacea87
5 августа 2019 в 14:25

0
мне кажется то о чем вы говорите нарушает концепцию машины в целом, если машина была остановлена, и вы после этого бросили эвент, то он не должен ее касаться, то есть у вас явно что то не по плану пошло, вы можете проверять стутус машины после восстанновления, и выставлять его принудительно в тот какой вам нужно, но это уже какое то костыльное решение имхо будет
Ответить
Jhumper
5 августа 2019 в 14:38

0
Ок. Вопрос про STP остаётся актуален. По первому вопросу пример такой. Допустим машина получила RESERVED, записала в БД состояние, после клиент кинул BUY, машина его получила, прошёл платёж, а дальше сервис упал. После восстановления будем иметь неконсистентный заказ. Если клиент ещё раз кинет BUY, то деньги спишутся ещё раз, но и служба доставки его не получила. Как всё таки допинать до терминального статуса такой кейс?
Ответить
PrinceKorwin
5 августа 2019 в 15:16

0
В вашем случае можно (нужно) декомпозировать модель состояний. Т.е. «деньги списаны» и «запрос доставлен в службу доставки» должны быть разными состояниями со своими переходами и логикой.
Если я правильно вас понял, то на одно состояние у вас завязаны две независимые логики, что не есть хорошо.
Ответить
Jhumper
5 августа 2019 в 15:37

0
А здесь уже возникает опять вопрос STP. Так как из «деньги списаны» в «запрос в доставке» переход должен проходить автоматически, т.е. сервис после восстановления работы должен сам решать такие кейсы, но есть много примеров, в которых не имеет смыслка декомпозиция иначе получится «Запрос на резервирование получен» -> «Запрос на резервирование доставлен в обработчик» -> «Запрос на резервирование в обработке» -> «Запрос на резервирование обработан» -> «Товар зарезервирован». И эти степы никакого отношения к бизнес процессу иметь не будут
Ответить
PrinceKorwin
5 августа 2019 в 16:03

0
Согласен. Не стоит всё доводить до абсурда, в том числе и дробление модели состояний.
В вашем примере уже фигурирует before, after, in_progress что само по себе уже явно намекает, что так дробить состояния не нужно и пора бы уже остановиться.
В примере выше — две независимые бизнес-логики тем более общающиеся (скорее всего) с разными внешними системами.
Тут можно решение обыграть через бронирование.Т.е. перед оплатой бронируется позиция на складе, идет оплата, бронь подтверждается. При таком подходе у системы шансов больше выжать и не потерять заказ (и товар).

переход должен проходить автоматически, т.е. сервис после восстановления работы должен сам решать такие кейсы

Если такое требование есть — то, возможно, лучшим решением будет использовать BPMN движки или Саги.

Бывает, что достаточно фонового процесса следящего за «подвисшими» сущностями и запускающий альтернативную цепочку состояний.
Ответить

mypanacea87
5 августа 2019 в 17:14

0
Допустим вы находитесь в статусе RESERVED, совешаете покупку, летит Event по которому должно произойти списание денег, и переход в статус BUY, логика на списание заложена в неком Action, вы делаете метод на списание транзакционным, навешиваете Action в конфигурации States, я в статье писал про этонемного, так вот, там сработка Action будет немного по другому, вы сначала зайдете в статус, а уже потому выполнится ваш транзакционный метод, если вдруг в нем случится ошибка машина вернется в предыдущее состояние, и списания не произойдет. Там разные комбинации на который можно навешивать ваши Action, stateEntry, stateExit, state, то есть можно настроить так, чтоб перестраховаться от того что вы упали сразу после списания
Ответить


mypanacea87
5 августа 2019 в 12:30

0
Основное преимущество описанного мной подхода в том что это будет возможность протестировать машину через unit-тест, а не через интеграционный или функциональный, если у вас в интеграционном тесте перед каждым тестом в тестовом профиле накатываются схемы в БД, таблицы и прочее прочее прочее, то ваши интеграционные тесты со временем нормально так затягиваются, и вы точно предпочтете тестировать через Unit, если будет такая возможность
Ответить
iboltaev
5 августа 2019 в 13:12

0
для таких задач лучше использовать Akka. Имхо.
Ответить

time2rfc
5 августа 2019 в 14:16

0
Тоже подумал про FSM но есть ощушение что затаскивание без всей akka инфраструкту́ры не лучшая идея.

Ответить
NikStrig
23 августа 2019 в 16:56

0
Спасибо за статью. Использовал Spring StateMachine для создания простого лексического анализатора. Интересует вопрос, насколько оправдано использование Spring StateMachine в данном случае?
Ответить

mypanacea87
23 августа 2019 в 17:00

0
думаю что вопрос насколько оправдано использование того или иного фремворка — вопрос относительный, все зависит от сложности скорее всего. Для несложных задач, скорее всего не стоит использовать, вы скорее всего усложните на ровном месте… но вот для более сложных эта штука становится серьезным подспорьем, попробуйте реализовать какой нибудь многоступенчатый сложный процесс без паттернов(например процедуру оформления дистанционного кредита), это будет сложно и запутанно, вы сами начнете думать в сторону какого то паттерна, а тут уже готовое решение. Машина в первую очередь это архитектурное решение.
Если вы свою задачу декомпозировали и разложили на концепцию машины, то почему бы и нет.
Ответить
NikStrig
23 августа 2019 в 20:39

0
Просто в каждой статье про лексический анализатор упоминается, что лучше всего его делать на конечных автоматах. А тут уже готовая реализация. По моим скромным впечатлениям, после первого знакомства, использование спринговской стейт машины сильно упростило написание логики анализатора, чем придумывание собственного костыля.